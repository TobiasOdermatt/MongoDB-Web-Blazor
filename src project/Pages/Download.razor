@page "/Download/{dbname}/{collectionname}"
@page "/Download/{dbname}"
@using MongoDB_Web.Data.DB;
@using Newtonsoft.Json;
@using Data.OTP;
@using Data.Helpers;
@inject DBController DBController;
@inject NavigationManager NavigationManager
@code {
    [Inject]
    IHttpContextAccessor? HttpContextAccessor { get; set; }

    [Parameter]
    public string? dbname { get; set; }

    [Parameter]
    public string? collectionname { get; set; }

    string userFilePath = $"{Directory.GetCurrentDirectory()}" + @"\Output\";
    string filename = "";
    [Inject]
    HttpClient? httpClient { get; set; }

    [Inject]
    IJSRuntime? jsRuntime { get; set; }

    string type;

    protected override async Task OnInitializedAsync()
    {
        if (dbname is null || DBController is null) return;

        if (HttpContextAccessor?.HttpContext == null) { return; }

        OTPAuthCookieManagement AuthManager = new(HttpContextAccessor.HttpContext);
        string? userUUID = AuthManager.GetUUID();

        userFilePath = Path.Combine(userFilePath, userUUID);

        Directory.CreateDirectory(userFilePath);

        string fileName;

        if (!string.IsNullOrEmpty(collectionname))
        {
            type = "collection";
            fileName = $"Collection-{collectionname}.json";
        }
        else
        {
            type = "database";
            fileName = $"DB-{dbname}.json";
        }

        userFilePath = Path.Combine(userFilePath, fileName);
        if (File.Exists(userFilePath))
            File.Delete(userFilePath);

        try
        {
            using (StreamWriter writer = new StreamWriter(userFilePath))
            {
                if (!string.IsNullOrEmpty(collectionname))
                {
                    await DBController.StreamCollectionExport(writer, dbname, collectionname);
                }
                else
                {
                    await DBController.StreamAllCollectionExport(writer, dbname);
                }
            }
            if (File.Exists(userFilePath))
            {
                await DownloadFile(fileName);
            }
        }
        catch (IOException e)
        {
            LogManager _ = new(LogManager.LogType.Error, "Streamwriter already in use");
        }
    }

    private async Task DownloadFile(string fileName)
    {
        if (jsRuntime == null)
            return;

        await jsRuntime.InvokeVoidAsync("downloadURI", $"/DownloadFile?fileName={fileName}", fileName);

    }
}
<input id="typeDB" value="type" type="hidden" />
<div>
    <progress id="fileProgress" max="100" value="0"style="
    min-width: 350px;"></progress>
    <div>Preparing the @type for download...</div>
    <br />
    <p id="status-text"></p>
</div>